use crate::UniqueFactorizationDomain;
use num_traits::Euclid;

/// Represents a Principal Ideal Domain (PID), an integral domain where every ideal is principal.
///
/// A Principal Ideal Domain (R, +, ·) is an integral domain that satisfies:
/// 1. (R, +, ·) is an integral domain
/// 2. Every ideal in R is principal (can be generated by a single element)
///
/// Formal Definition:
/// Let R be an integral domain. R is a PID if for every ideal I ⊆ R, there exists an element a ∈ R
/// such that I = (a) = {ra | r ∈ R}.
pub trait PrincipalIdealDomain: UniqueFactorizationDomain + Euclid {}

impl<T> PrincipalIdealDomain for T where T: UniqueFactorizationDomain + Euclid {}

#[cfg(test)]
mod tests {
    use crate::concrete::Z5;
    use crate::PrincipalIdealDomain;
    use num_traits::Zero;

    #[test]
    fn test_z5_implements_pid() {
        fn assert_pid<T: PrincipalIdealDomain>() {}
        assert_pid::<Z5>();
    }

    #[test]
    fn test_z5_euclidean_division() {
        for i in 0..5 {
            for j in 1..5 {
                // Avoid division by zero
                let a = Z5::new(i);
                let b = Z5::new(j);
                let (q, r) = a.div_rem_euclid(&b);
                assert_eq!(a, q * b + r);
                assert!(r.is_zero() || r < b);
            }
        }
    }

    // TODO(Test GCD)

    #[test]
    fn test_z5_principal_ideals() {
        for i in 0..5 {
            let a = Z5::new(i);
            let ideal = generate_ideal(a);
            assert!(is_principal_ideal(&ideal));
        }
    }

    fn generate_ideal(a: Z5) -> Vec<Z5> {
        (0..5).map(|i| a * Z5::new(i)).collect()
    }

    fn is_principal_ideal(ideal: &[Z5]) -> bool {
        if ideal.is_empty() {
            return true; // The zero ideal is principal
        }
        let binding = Z5::zero();
        let generator = ideal.iter().find(|&&x| !x.is_zero()).unwrap_or(&binding);
        let generated_ideal = generate_ideal(*generator);
        ideal.iter().all(|elem| generated_ideal.contains(elem))
    }
}
